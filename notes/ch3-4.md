# 语法分析、抽象语法


## 左值`lvalue` 的规则定义

书上提到文法上的`移进-规约冲突` :

```
varibale[expression]
type-id[expression] of expression
```

如果处理如下，

```
lvalue: 
        ID                       
      | lvalue LBRACK exp RBRACK 
      | lvalue DOT ID 

array_create : 
                ID LBRACK exp RBRACK OF exp 
```

状态图为

```
state 1

   21 lvalue: ID .
   24 func_call: ID . LPAREN explist RPAREN
   41 record_create: ID . LBRACE record_create_list RBRACE
   47 array_create: ID . LBRACK exp RBRACK OF exp

    LBRACK  shift, and go to state 21
    LPAREN  shift, and go to state 22
    LBRACE  shift, and go to state 23

    $default  reduce using rule 21 (lvalue)
```

遇到`ID[` 时直接就到`state 21`，规则21 `lvalue: ID` 没有机会规约，也就到不了`lvalue: lvalue LBARCK exp PBRACK`，
因此，修改文法为

```
lvalue: 
        ID                       
      | lvalue LBRACK exp RBRACK 
      | lvalue DOT ID 
      | ID  LBRACK exp RBRACK 
```

依旧有冲突

```
state 2

   21 lvalue: ID .
   22       | ID . LBRACK exp RBRACK
   25 func_call: ID . LPAREN explist RPAREN
   42 record_create: ID . LBRACE record_create_list RBRACE
   48 array_create: ID . LBRACK exp RBRACK OF exp

    LPAREN  shift, and go to state 22
    LBRACK  shift, and go to state 23
    LBRACE  shift, and go to state 24

    LBRACK    [reduce using rule 21 (lvalue)]
    $default  reduce using rule 21 (lvalue)
```

增加优先级

```
%nonassoc ID
%nonassoc LBRACK
```

## 列表相关规则的右递归

```
seqexp :
         exp                    { $$ = A_ExpList($1, NULL); }
       | exp SEMICOLON seqexp   { $$ = A_ExpList($1, $3); }
```

因为`A_ExpList` 构造列表每次都是向前插入的，因此这里使用右递归的方式，否则列表顺序会倒置。


## 序列、圆括号、无值

这几个的界限比较模糊

- `序列` 形如`(exp; exp; ...)` 要求两个或两个以上表达式
- `圆括号` 形如`(exp)` 如 `if (a > b)` 中，起到*group* 的作用
- `无值` 形如`()` 

这几个都会被解释为`SeqExp(ExpList())` 感觉怪怪的。


